<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Productivity Sliding Puzzle</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 10px;
  }

  #controls {
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    width: 90vw;
    max-width: 400px;
  }

  #puzzle-container {
    display: grid;
    gap: 2px;
    width: 100%;
    aspect-ratio: 1;
    touch-action: manipulation;
    position: relative;
  }

  .tile {
    background-size: cover;
    background-position: center;
    cursor: pointer;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: white;
    user-select: none;
    border-radius: 4px;
  }

  .bar-container {
    width: 100%;
    height: 20px;
    background-color: #ddd;
    border-radius: 10px;
    overflow: hidden;
    margin-top: 3px;
  }

  .bar-fill {
    height: 100%;
    background-color: #4caf50;
    width: 0%;
    transition: width 0.4s ease;
  }

  #moves, #timer, #score {
    margin: 3px;
    font-weight: bold;
  }

  button, select, input {
    padding: 8px 12px;
    margin: 2px;
    cursor: pointer;
  }

  .confetti {
    position: absolute;
    width: 8px;
    height: 8px;
    background-color: red;
    animation: confetti-fall 1s forwards;
  }

  @keyframes confetti-fall {
    0% { transform: translate(0,0) rotate(0deg); opacity:1; }
    100% { transform: translate(var(--x), 100vh) rotate(360deg); opacity:0; }
  }

  @media (max-width: 500px) {
    #controls {
      width: 90vw;
    }
  }
</style>
</head>
<body>

<div id="controls">
  <input type="file" id="imageInput" accept="image/*" multiple>
  <select id="difficultySelect">
    <option value="4">Normal (4x4)</option>
    <option value="5">Hard (5x5)</option>
  </select>
  <label for="timerInput">Work session (minutes): </label>
  <input type="number" id="timerInput" min="1" max="120" value="25">
  <button id="startButton">Start Puzzle</button>

  <div id="moves">Moves left: 0</div>
  <div class="bar-container">
    <div id="movesBar" class="bar-fill"></div>
  </div>

  <div id="timer">Timer: 25:00</div>
  <div class="bar-container">
    <div id="timerBar" class="bar-fill"></div>
  </div>

  <div id="score">Puzzles solved: 0</div>
</div>

<div id="puzzle-container"></div>

<!-- Sound effects -->
<audio id="moveSound" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_low.ogg"></audio>
<audio id="completeSound" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>
<audio id="rewardSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg"></audio>

<script>
let PUZZLE_SIZE = parseInt(localStorage.getItem('difficulty')) || 4;
const MOVES_PER_SESSION = 30;
let movesLeft = parseInt(localStorage.getItem('movesLeft')) || 0;
let carryoverMoves = parseInt(localStorage.getItem('carryoverMoves')) || 0;
let puzzle = [];
let emptyPos = {x: PUZZLE_SIZE-1, y: PUZZLE_SIZE-1};
let images = JSON.parse(localStorage.getItem('images')) || [];
let currentImageIndex = parseInt(localStorage.getItem('currentImageIndex')) || 0;
let timer = 25 * 60;
let timerInterval;
let puzzlesSolved = parseInt(localStorage.getItem('puzzlesSolved')) || 0;

const puzzleContainer = document.getElementById('puzzle-container');
const movesDisplay = document.getElementById('moves');
const movesBar = document.getElementById('movesBar');
const timerDisplay = document.getElementById('timer');
const timerBar = document.getElementById('timerBar');
const scoreDisplay = document.getElementById('score');
const imageInput = document.getElementById('imageInput');
const startButton = document.getElementById('startButton');
const difficultySelect = document.getElementById('difficultySelect');
const timerInput = document.getElementById('timerInput');

const moveSound = document.getElementById('moveSound');
const completeSound = document.getElementById('completeSound');
const rewardSound = document.getElementById('rewardSound');

difficultySelect.value = PUZZLE_SIZE;

imageInput.addEventListener('change', e => {
    const files = e.target.files;
    if (!files.length) return;
    images = [];
    for (const file of files) {
        const reader = new FileReader();
        reader.onload = function(event) {
            images.push(event.target.result);
            localStorage.setItem('images', JSON.stringify(images));
        }
        reader.readAsDataURL(file);
    }
    currentImageIndex = 0;
    localStorage.setItem('currentImageIndex', currentImageIndex);
});

difficultySelect.addEventListener('change', () => {
    PUZZLE_SIZE = parseInt(difficultySelect.value);
    localStorage.setItem('difficulty', PUZZLE_SIZE);
});

startButton.addEventListener('click', () => {
    if (!images.length) {
        alert('Please select at least one image first.');
        return;
    }
    loadCurrentImage(initPuzzle);
    startTimer();
});

function loadCurrentImage(callback) {
    const imgSrc = images[currentImageIndex];
    img = new Image();
    img.onload = callback;
    img.src = imgSrc;
}

function initPuzzle() {
    puzzle = [];
    puzzleContainer.innerHTML = '';
    puzzleContainer.style.gridTemplateColumns = `repeat(${PUZZLE_SIZE}, 1fr)`;
    puzzleContainer.style.gridTemplateRows = `repeat(${PUZZLE_SIZE}, 1fr)`;

    for (let y = 0; y < PUZZLE_SIZE; y++) {
        puzzle[y] = [];
        for (let x = 0; x < PUZZLE_SIZE; x++) {
            if (x === PUZZLE_SIZE-1 && y === PUZZLE_SIZE-1) {
                puzzle[y][x] = null;
                continue;
            }
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.style.backgroundImage = `url(${img.src})`;
            tile.style.backgroundSize = `${PUZZLE_SIZE*100}% ${PUZZLE_SIZE*100}%`;
            tile.style.backgroundPosition = `${(-x * 100)}% ${(-y * 100)}%`;
            tile.dataset.x = x;
            tile.dataset.y = y;
            tile.addEventListener('click', () => moveTile(x, y));
            puzzleContainer.appendChild(tile);
            puzzle[y][x] = tile;
        }
    }
    emptyPos = {x: PUZZLE_SIZE-1, y: PUZZLE_SIZE-1};
    scramblePuzzle();
    updateMovesDisplay();
    updateTimerBar();
}

function scramblePuzzle() {
    let moves = 1000;
    while (moves > 0) {
        const neighbors = getNeighbors(emptyPos.x, emptyPos.y);
        const choice = neighbors[Math.floor(Math.random() * neighbors.length)];
        swapTiles(emptyPos, choice);
        emptyPos = {x: choice.x, y: choice.y};
        moves--;
    }
}

function getNeighbors(x, y) {
    const neighbors = [];
    if (x > 0) neighbors.push({x:x-1, y:y});
    if (x < PUZZLE_SIZE-1) neighbors.push({x:x+1, y:y});
    if (y > 0) neighbors.push({x:x, y:y-1});
    if (y < PUZZLE_SIZE-1) neighbors.push({x:x, y:y+1});
    return neighbors;
}

function moveTile(x, y) {
    if (movesLeft + carryoverMoves <= 0) {
        alert('Out of moves! Complete a work session to earn more.');
        return;
    }
    const dx = Math.abs(x - emptyPos.x);
    const dy = Math.abs(y - emptyPos.y);
    if ((dx + dy) === 1) {
        swapTiles({x, y}, emptyPos);
        emptyPos = {x, y};
        moveSound.currentTime = 0;
        moveSound.play();
        if (carryoverMoves > 0) carryoverMoves--;
        else movesLeft--;
        updateMovesDisplay();
        saveProgress();
        if (checkWin()) {
            puzzlesSolved++;
            scoreDisplay.textContent = `Puzzles solved: ${puzzlesSolved}`;
            saveProgress();
            completeSound.currentTime = 0;
            completeSound.play();
            showConfetti();
            alert('Puzzle Solved! Loading next image...');
            nextImagePuzzle();
        }
    }
}

function nextImagePuzzle() {
    currentImageIndex = (currentImageIndex + 1) % images.length;
    localStorage.setItem('currentImageIndex', currentImageIndex);
    loadCurrentImage(initPuzzle);
}

function swapTiles(pos1, pos2) {
    const temp = puzzle[pos1.y][pos1.x];
    puzzle[pos1.y][pos1.x] = puzzle[pos2.y][pos2.x];
    puzzle[pos2.y][pos2.x] = temp;

    if (puzzle[pos1.y][pos1.x]) puzzleContainer.appendChild(puzzle[pos1.y][pos1.x]);
    if (puzzle[pos2.y][pos2.x]) puzzleContainer.appendChild(puzzle[pos2.y][pos2.x]);
}

function updateMovesDisplay() {
    const totalMoves = movesLeft + carryoverMoves;
    movesDisplay.textContent = `Moves left: ${totalMoves}`;
    const maxMoves = MOVES_PER_SESSION * 2; 
    movesBar.style.width = `${Math.min(totalMoves / maxMoves * 100, 100)}%`;
}

function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    const sessionMinutes = parseInt(timerInput.value) || 25;
    timer = sessionMinutes * 60; 
    updateTimerBar();
    timerInterval = setInterval(() => {
        timer--;
        const minutes = String(Math.floor(timer/60)).padStart(2,'0');
        const seconds = String(timer%60).padStart(2,'0');
        timerDisplay.textContent = `Timer: ${minutes}:${seconds}`;
        updateTimerBar();
        if (timer <= 0) {
            clearInterval(timerInterval);
            carryoverMoves += MOVES_PER_SESSION;
            rewardSound.currentTime = 0;
            rewardSound.play();
            animateMoveGain();
            alert(`${sessionMinutes} minute session complete! You earned ${MOVES_PER_SESSION} moves.`);
            updateMovesDisplay();
            saveProgress();
        }
    }, 1000);
}

function updateTimerBar() {
    const percent = ((parseInt(timerInput.value)*60 - timer) / (parseInt(timerInput.value)*60)) * 100;
    timerBar.style.width = `${percent}%`;
}

function animateMoveGain() {
    movesBar.style.transition = 'width 0.4s, background-color 0.2s';
    movesBar.style.backgroundColor = '#ffd700';
    setTimeout(() => {
        movesBar.style.backgroundColor = '#4caf50';
    }, 300);
}

function checkWin() {
    for (let y = 0; y < PUZZLE_SIZE; y++) {
        for (let x = 0; x < PUZZLE_SIZE; x++) {
            if (x === PUZZLE_SIZE-1 && y === PUZZLE_SIZE-1) continue;
            const tile = puzzle[y][x];
            if (!tile) return false;
            if (parseInt(tile.dataset.x) !== x || parseInt(tile.dataset.y) !== y) return false;
        }
    }
    return true;
}

function showConfetti() {
    for (let i = 0; i < 30; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.backgroundColor = `hsl(${Math.random()*360}, 70%, 50%)`;
        confetti.style.setProperty('--x', `${(Math.random()-0.5)*200}px`);
        puzzleContainer.appendChild(confetti);
        setTimeout(() => confetti.remove(), 1000);
    }
}

function saveProgress() {
    localStorage.setItem('movesLeft', movesLeft);
    localStorage.setItem('carryoverMoves', carryoverMoves);
    localStorage.setItem('puzzlesSolved', puzzlesSolved);
    localStorage.setItem('difficulty', PUZZLE_SIZE);
    localStorage.setItem('currentImageIndex', currentImageIndex);
    localStorage.setItem('images', JSON.stringify(images));
}
</script>

</body>
</html>
